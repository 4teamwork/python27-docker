CVE-2024-6923: Encode newlines in headers, and verify headers are sound

Per RFC 2047:

> [...] these encoding schemes allow the
> encoding of arbitrary octet values, mail readers that implement this
> decoding should also ensure that display of the decoded data on the
> recipient's terminal will not cause unwanted side-effects

It seems that the "quoted-word" scheme is a valid way to include
a newline character in a header value, just like we already allow
undecodable bytes or control characters.
They do need to be properly quoted when serialized to text, though.

This should fail for custom fold() implementations that aren't careful
about newlines.

Backported from https://github.com/python/cpython/pull/122611

--- a/Lib/email/errors.py
+++ b/Lib/email/errors.py
@@ -55,3 +55,6 @@ class MalformedHeaderDefect(MessageDefec
 
 class MultipartInvariantViolationDefect(MessageDefect):
     """A message claimed to be a multipart but no subparts were found."""
+
+class HeaderWriteError(MessageError):
+    """Error while writing headers."""
--- a/Lib/email/generator.py
+++ b/Lib/email/generator.py
@@ -13,11 +13,13 @@ import warnings
 
 from cStringIO import StringIO
 from email.header import Header
+from email.errors import HeaderWriteError
 
 UNDERSCORE = '_'
 NL = '\n'
 
 fcre = re.compile(r'^From ', re.MULTILINE)
+NEWLINE_WITHOUT_FWSP = re.compile(r'\r\n[^ \t]|\r[^ \n\t]|\n[^ \t]')
 
 def _is8bitstring(s):
     if isinstance(s, str):
@@ -139,6 +141,9 @@

     def _write_headers(self, msg):
         for h, v in msg.items():
+            if NEWLINE_WITHOUT_FWSP.search(h):
+                raise HeaderWriteError(
+                        'header contains newline: %s' % h)
             print >> self._fp, '%s:' % h,
             if self._maxheaderlen == 0:
                 # Explicit no-wrapping
--- a/Lib/email/header.py
+++ b/Lib/email/header.py
@@ -24,6 +24,7 @@ SPACE = ' '
 USPACE = u' '
 SPACE8 = ' ' * 8
 UEMPTYSTRING = u''
+NLSET = {'\n', '\r'}
 
 MAXLINELEN = 76
 
@@ -360,6 +361,8 @@ class Header:
                 continue
             if charset is None or charset.header_encoding is None:
                 s = header
+            elif any(nl in header for nl in NLSET):
+                s = charset.header_encode(header)
             else:
                 s = charset.header_encode(header)
             # Don't add more folding whitespace than necessary
--- a/Lib/email/test/test_email_renamed.py
+++ b/Lib/email/test/test_email_renamed.py
@@ -2580,6 +2580,22 @@
         eq(headers, ['A', 'B', 'CC'])
         eq(msg.get_payload(), 'body')
 
+    def test_verify_generated_headers(self):
+        """Test that the generator prevents header injection"""
+        msg = Message() 
+        value_to_test = 'Value\r\nBad Injection\r\n'
+        h = Header("sample_header_value", header_name=value_to_test)
+        msg[value_to_test] = h
+        sfp = StringIO()
+        g = Generator(sfp)
+    
+        # Expect an exception for invalid header values
+        try:
+            g.flatten(msg)
+            self.fail("HeaderWriteError was not raised for input: %s" % value_to_test)
+        except email.errors.HeaderWriteError:
+            pass
+
 
 
 class TestBase64(unittest.TestCase):
